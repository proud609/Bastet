{
  "name": "owasp2025",
  "nodes": [
    {
      "parameters": {
        "options": {}
      },
      "id": "21caf61d-1659-4a8f-bb33-0046b084e990",
      "name": "When chat message received",
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.1,
      "position": [-3220, 2810],
      "webhookId": "b1994562-8677-41bd-a2dd-3ad9245498ea"
    },
    {
      "parameters": {
        "content": "## Knowledge:\nOWASP TOP10 2025\nhttps://owasp.org/www-project-smart-contract-top-10/",
        "height": 120,
        "width": 540
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [-3940, 1900],
      "id": "9aae1a82-e68d-4ec5-9616-fc4ceefe89ae",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "content": "### SC01:2025 - Improper Access Control\nhttps://blog.solidityscan.com/access-control-vulnerabilities-in-smart-contracts-a31757f5d707",
        "width": 380
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [-2240, 940],
      "id": "e2c48b1d-16b6-47df-901c-b3898bb9efa2",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "content": "### SC02:2025 - Price Oracle Manipulation\nhttps://blog.solidityscan.com/bonqdao-protocol-hack-analysis-oracle-manipulation-8e6978149a66",
        "width": 380
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [-2240, 1320],
      "id": "ecad2db4-426a-42d6-84ec-89e327a5c8c9",
      "name": "Sticky Note2"
    },
    {
      "parameters": {
        "content": "### SC03:2025 - Logic Errors\nhttps://blog.solidityscan.com/level-finance-hack-analysis-16fda3996ecb",
        "width": 380
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [-2240, 1560],
      "id": "2406bcd0-fac0-4e0f-84c6-4ec97b5b75e7",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "content": "### SC04:2025 - Lack of Input\nFile 46 of 50 : OneInchImpl.sol\nhttps://blog.solidityscan.com/socket-gateway-hack-analysis-b0e9567f7d3e",
        "height": 120,
        "width": 640
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [-2380, 1760],
      "id": "90a0fc77-e65e-4cb7-9fa5-f29123a4e237",
      "name": "Sticky Note4"
    },
    {
      "parameters": {
        "content": "### SC05:2025 - Reentrancy\nhttps://medium.com/chainwall-io/reentrancy-attack-in-smart-contracts-4837ed0f9d73",
        "width": 380
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [-2240, 1940],
      "id": "066436f2-3f57-40e4-b0a7-fa5ed2db7c28",
      "name": "Sticky Note5"
    },
    {
      "parameters": {
        "content": "### SC06:2025 Unchecked External Calls\nhttps://blog.solidityscan.com/security-issues-with-delegate-calls-4ae64d775b76",
        "width": 380
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [-2240, 2160],
      "id": "6756bcc9-9da9-4181-8957-2335af056a10",
      "name": "Sticky Note6"
    },
    {
      "parameters": {
        "content": "### SC07:2025 - Flash Loan Attacks\nhttps://blog.solidityscan.com/doughfina-hack-analysis-685ed56adb19",
        "width": 380
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [-2240, 2360],
      "id": "785542bc-43cb-4d14-b130-b44ad90dd3b9",
      "name": "Sticky Note7"
    },
    {
      "parameters": {
        "content": "### SC08:2025 - Integer Overflow and Underflow\nhttps://blog.solidityscan.com/poolz-finance-hack-analysis-still-experiencing-overflow-fcf35ab8a6c5",
        "width": 380
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [-2240, 2560],
      "id": "ce1a42a4-5da8-4298-b175-2fdacf066f06",
      "name": "Sticky Note8"
    },
    {
      "parameters": {
        "content": "### SC09:2025 - Insecure Randomness\nhttps://blog.solidityscan.com/roast-football-hack-analysis-e9316170c443",
        "width": 380
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [-2240, 2760],
      "id": "879041e0-56a7-4e50-81de-2aa31626a83a",
      "name": "Sticky Note9"
    },
    {
      "parameters": {
        "content": "### SC10:2025 - Denial Of Service\nhttps://medium.com/@JohnnyTime/solidity-smart-contract-unbounded-loops-dos-attack-vulnerability-explained-with-real-example-f4b4aca27c08",
        "width": 380
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [-2240, 3000],
      "id": "e2b490d1-8917-4781-8823-6b15de591941",
      "name": "Sticky Note10"
    },
    {
      "parameters": {
        "numberInputs": 10
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [-2624, 1913],
      "id": "dbed7722-f9dc-4289-b2f2-cbd8606de156",
      "name": "Merge"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [-2972, 1180],
      "id": "2eb1e572-64c1-4f9a-bd34-967e22f87f26",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "6qICvMVQ9Mixvcjz",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"array\",\n  \"items\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"summary\": {\n        \"type\": \"string\",\n        \"description\": \"Brief summary of the vulnerability\"\n      },\n      \"severity\": {\n        \"type\": \"string\",\n        \"items\": {\n          \"type\": \"string\",\n          \"enum\": [\"high\", \"medium\", \"low\"]\n        },\n        \"description\": \"Severity level of the vulnerability\"\n      },\n      \"vulnerability_details\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"function_name\": {\n            \"type\": \"string\",\n            \"description\": \"Function name where the vulnerability is found\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"Detailed description of the vulnerability\"\n          }\n        },\n        \"required\": [\"function_name\", \"description\"]\n      },\n      \"code_snippet\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"type\": \"string\"\n        },\n        \"description\": \"Code snippet showing the vulnerability\",\n        \"default\": []\n      },\n      \"recommendation\": {\n        \"type\": \"string\",\n        \"description\": \"Recommendation to fix the vulnerability\"\n      }\n    },\n    \"required\": [\"summary\", \"severity\", \"vulnerability_details\", \"code_snippet\", \"recommendation\"]\n  },\n  \"additionalProperties\": false\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [-2852, 1180],
      "id": "cf4abc61-0ab1-4cb1-9b13-483c78e5b80c",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "bb270c58-7acd-4719-9d49-16b049a2de47",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [-3880, 1260],
      "id": "3305a94e-309c-4f8a-95bb-2b74ecb26048",
      "name": "Webhook",
      "webhookId": "bb270c58-7acd-4719-9d49-16b049a2de47"
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "={{ $execution.id }}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [-3440, 1110],
      "id": "7ae30bbd-880a-4749-b752-e25b6b25b1e4",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "160ecd30-898d-4e0f-9879-1a0cd6a91190",
              "name": "chatInput",
              "value": "{{ $json.body.prompt }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [-3220, 1260],
      "id": "8da8a555-19a7-4c5e-a2e9-6bc074c30dac",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=You are a smart contract auditor. After reading the following vulnerability knowledge and understanding correct and incorrect examples, detect the problem in the contract code.\n\n### Vulnerability Knowledge\n\n**Improper Access Control**\nAn access control vulnerability is a security flaw that allows unauthorized users to access or modify the contract’s data or functions. These vulnerabilities arise when the contract’s code fails to restrict access adequately based on user permission levels. Access control in smart contracts can relate to governance and critical logic, such as minting tokens, voting on proposals, withdrawing funds, pausing and upgrading the contracts, and changing ownership.\n\n### Examples\n\n#### Incorrect Example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_AccessControl {\n    mapping(address => uint256) public balances;\n\n    // Burn function with no access control\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n    }\n}\n```\n\nImpact:\n*Attackers can gain unauthorized access to critical functions and data within the contract, compromising its integrity and security.\n*Vulnerabilities can lead to the theft of funds or assets controlled by the contract, causing significant financial damage to users and stakeholders.\n\n#### Correct Example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Import the Ownable contract from OpenZeppelin to manage ownership\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Solidity_AccessControl is Ownable {\n    mapping(address => uint256) public balances;\n\n    // Burn function with proper access control, only accessible by the contract owner\n    function burn(address account, uint256 amount) public onlyOwner {\n        _burn(account, amount);\n    }\n}\n```\n\n**Suggestion**\n\n*Ensure initialization functions can only be called once and exclusively by authorized entities.\n*Use established access control patterns like Ownable or RBAC (Role-Based Access Control) in your contracts to manage permissions and ensure that only authorized users can access certain functions. This can be done by adding appropriate access control modifiers, such as onlyOwner or custom roles to sensitive functions.\n\n### Task to Perform\nFollow the examples above to examine each contract and check if it contains this issue. If you find any potential issues, record them using the format below.\n\n### Output Format\n\nIf NO concrete vulnerability found, output a empty array\n\nOtherwise, follow the format below:\n\n```\n[\n    {\n        \"summary\":  \"summary of the vulnerabilities\",\n        \"vulnerability_details\": {\n            \"function_name\": \"Name of the function\",\n            \"description\": \"a brief description of the vulnerability\"\n        },\n    \n        \"code_snippet\": [\n            \"code snippet in the file\"\n        ],\n    \n        \"recommendation\": \"recommendation of how to fix the vulnerability\"\n    \n    }\n]\n```"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [-3000, 960],
      "id": "28b8de7f-9372-42e9-8717-05b6b15089b1",
      "name": "SC01:2025 - Improper Access Control",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=You are a smart contract auditor. After reading the following vulnerability knowledge and understanding correct and incorrect examples, detect the problem in the contract code.\n\n### Vulnerability Knowledge\n\n**Price Oracle Manipulation**\nPrice Oracle Manipulation is a critical vulnerability in smart contracts that rely on external data feeds (oracles) to fetch prices or other information. In decentralized finance (DeFi), oracles are used to provide real-world data, such as asset prices, to smart contracts. However, if the data provided by the oracle is manipulated, it can result in incorrect contract behavior. Attackers can exploit oracles by manipulating the data they supply, leading to devastating consequences such as unauthorized withdrawals, excessive leverage, or even draining liquidity pools. Proper safeguards and validation mechanisms are essential to prevent this type of attack.\n\n### Examples\n\n#### Incorrect Example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPriceFeed {\n    function getLatestPrice() external view returns (int);\n}\n\ncontract PriceOracleManipulation {\n    address public owner;\n    IPriceFeed public priceFeed;\n\n    constructor(address _priceFeed) {\n        owner = msg.sender;\n        priceFeed = IPriceFeed(_priceFeed);\n    }\n\n    function borrow(uint256 amount) public {\n        int price = priceFeed.getLatestPrice();\n        require(price > 0, \"Price must be positive\");\n\n        // Vulnerability: No validation or protection against price manipulation\n        uint256 collateralValue = uint256(price) * amount;\n\n        // Borrow logic based on manipulated price\n        // If an attacker manipulates the oracle, they could borrow more than they should\n    }\n\n    function repay(uint256 amount) public {\n        // Repayment logic\n    }\n}\n```\n\nImpact:\n*Attackers could manipulate the oracle to inflate the price of an asset, allowing them to borrow more funds than they would otherwise be entitled to.\n*In cases where the manipulated price leads to a false assessment of collateral, legitimate users may face liquidation due to incorrect valuations.\n*If an oracle is compromised, attackers can exploit the manipulated data to drain the contract’s liquidity pools or even cause a contract to become insolvent.\n\n#### Correct Example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPriceFeed {\n    function getLatestPrice() external view returns (int);\n}\n\ncontract PriceOracleManipulation {\n    address public owner;\n    IPriceFeed public priceFeed;\n    int public minPrice = 1000; // Set minimum acceptable price\n    int public maxPrice = 2000; // Set maximum acceptable price\n\n    constructor(address _priceFeed) {\n        owner = msg.sender;\n        priceFeed = IPriceFeed(_priceFeed);\n    }\n\n    function borrow(uint256 amount) public {\n        int price = priceFeed.getLatestPrice();\n        require(price > 0 && price >= minPrice && price <= maxPrice, \"Price manipulation detected\");\n\n        uint256 collateralValue = uint256(price) * amount;\n\n        // Borrow logic based on valid price\n    }\n\n    function repay(uint256 amount) public {\n        // Repayment logic\n    }\n}\n```\n\n**Suggestion**\n\n*Aggregate data from multiple, independent oracles to reduce the risk of manipulation by any single source.\n*Set minimum and maximum thresholds for the prices received from the oracle to prevent drastic price swings from affecting the contract’s logic.\n*Introduce a time lock between price updates to prevent instant changes that could be exploited by attackers.\n*Use cryptographic proofs to ensure the authenticity of data received from oracles, such as requiring signatures from trusted parties.\n\n### Task to Perform\nFollow the examples above to examine each contract and check if it contains this issue. If you find any potential issues, record them using the format below.\n\n### Output Format\n\nIf NO concrete vulnerability found, output a empty array\n\nOtherwise, follow the format below:\n\n```\n[\n    {\n        \"summary\":  \"summary of the vulnerabilities\",\n        \"vulnerability_details\": {\n            \"function_name\": \"Name of the function\",\n            \"description\": \"a brief description of the vulnerability\"\n        },\n    \n        \"code_snippet\": [\n            \"code snippet in the file\"\n        ],\n    \n        \"recommendation\": \"recommendation of how to fix the vulnerability\"\n    \n    }\n]\n```"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [-3000, 1360],
      "id": "2b575e11-e509-4a3e-82be-c46dc13866cb",
      "name": "SC02:2025 - Price Oracle Manipulation",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=You are a smart contract auditor. After reading the following vulnerability knowledge and understanding correct and incorrect examples, detect the problem in the contract code.\n\n### Vulnerability Knowledge\n\n**Logic Errors**\nLogic errors, also known as business logic vulnerabilities, are subtle flaws in smart contracts. They occur when the contract’s code does not match its intended behavior. These errors can manifest in various forms, such as faulty math in reward distribution, improper token minting mechanisms, or incorrect calculations in lending and borrowing logic. Such vulnerabilities are elusive, hiding within the contract’s logic and waiting to be discovered.\n\nExamples of Logic Errors:\n*Faulty Reward Distribution: Miscalculations in dividing rewards among stakeholders, leading to unfair allocations.\n*Improper Token Minting: Unchecked or erroneous minting logic that allows infinite or unintended token generation.\n*Lending Pool Imbalances: Incorrect tracking of deposits and withdrawals, causing inconsistencies in pool reserves.\n\n### Examples\n\n#### Incorrect Example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_LogicErrors {\n    mapping(address => uint256) public userBalances;\n    uint256 public totalLendingPool;\n\n    function deposit() public payable {\n        userBalances[msg.sender] += msg.value;\n        totalLendingPool += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(userBalances[msg.sender] >= amount, \"Insufficient balance\");\n\n        // Faulty calculation: Incorrectly reducing the user's balance without updating the total lending pool\n        userBalances[msg.sender] -= amount;\n\n        // This should update the total lending pool, but it's omitted here.\n\n        payable(msg.sender).transfer(amount);\n    }\n\n    function mintReward(address to, uint256 rewardAmount) public {\n        // Faulty minting logic: Reward amount not validated\n        userBalances[to] += rewardAmount;\n    }\n}\n```\n\nImpact:\n*Logic errors can cause a smart contract to behave unexpectedly or even become entirely unusable. These errors can lead to:\n**Loss of Funds: Incorrect reward distribution or pool imbalances draining contract funds.\n**Excessive Token Minting: Inflating token supply, undermining trust and value.\n**Operational Failures: Contracts failing to perform their intended functions.\n*These consequences can result in significant financial and operational losses for users and stakeholders.\n\n#### Correct Example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_LogicErrors {\n    mapping(address => uint256) public userBalances;\n    uint256 public totalLendingPool;\n\n    function deposit() public payable {\n        userBalances[msg.sender] += msg.value;\n        totalLendingPool += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(userBalances[msg.sender] >= amount, \"Insufficient balance\");\n\n        // Correctly reducing the user's balance and updating the total lending pool\n        userBalances[msg.sender] -= amount;\n        totalLendingPool -= amount;\n\n        payable(msg.sender).transfer(amount);\n    }\n\n    function mintReward(address to, uint256 rewardAmount) public {\n        require(rewardAmount > 0, \"Reward amount must be positive\");\n\n        // Safeguarded minting logic\n        userBalances[to] += rewardAmount;\n    }\n}\n```\n\n\n**Suggestion**\n\n*Always validate your code by writing comprehensive test cases that cover all possible business logic scenarios.\n*Conduct thorough code reviews and audits to identify and fix potential logic errors.\nDocument the intended behavior of each function and module, and compare it to the actual implementation to ensure alignment.\n*Implement guardrails, such as:\n**Safe math libraries to prevent calculation errors.\n**Proper checks and balances for token minting.\n**Auditable reward distribution algorithms.\n\n### Task to Perform\nFollow the examples above to examine each contract and check if it contains this issue. If you find any potential issues, record them using the format below.\n\n### Output Format\n\nIf NO concrete vulnerability found, output a empty array\n\nOtherwise, follow the format below:\n\n```\n[\n    {\n        \"summary\":  \"summary of the vulnerabilities\",\n        \"vulnerability_details\": {\n            \"function_name\": \"Name of the function\",\n            \"description\": \"a brief description of the vulnerability\"\n        },\n    \n        \"code_snippet\": [\n            \"code snippet in the file\"\n        ],\n    \n        \"recommendation\": \"recommendation of how to fix the vulnerability\"\n    \n    }\n]\n```"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [-3000, 1560],
      "id": "81a41625-8a09-4608-b820-250ec3bb38b0",
      "name": "SC03:2025 - Logic Errors",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=You are a smart contract auditor. After reading the following vulnerability knowledge and understanding correct and incorrect examples, detect the problem in the contract code.\n\n### Vulnerability Knowledge\n\n**Lack of Input Validation**\nInput validation ensures that a smart contract processes only valid and expected data. When contracts fail to validate incoming inputs, they inadvertently expose themselves to security risks such as logic manipulation, unauthorized access, and unexpected behavior.For example, if a contract assumes user inputs are always valid without verification, attackers can exploit this trust to introduce malicious data. This lack of input validation compromises the security and reliability of the smart contract.\n\n### Examples\n\n#### Incorrect Example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_LackOfInputValidation {\n    mapping(address => uint256) public balances;\n\n    function setBalance(address user, uint256 amount) public {\n        // The function allows anyone to set arbitrary balances for any user without validation.\n        balances[user] = amount;\n    }\n}\n```\n\nImpact:\n*Attackers can manipulate inputs to drain funds, steal tokens, or cause other financial harm.\n*Improper inputs can corrupt state variables, leading to unreliable and insecure contract behavior.\n*Attackers may exploit the contract to perform unauthorized transactions or operations, impacting both the user and the broader system.\n\n#### Correct Example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract LackOfInputValidation {\n    mapping(address => uint256) public balances;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not authorized\");\n        _;\n    }\n\n    function setBalance(address user, uint256 amount) public onlyOwner {\n        require(user != address(0), \"Invalid address\");\n        balances[user] = amount;\n    }\n}\n```\n\n\n**Suggestion**\n\n*Ensure that inputs conform to the expected type.\n*Validate that inputs fall within acceptable boundaries.\n*Ensure that only authorized entities can invoke specific functions.\n*Validate the structure of inputs, such as address formats or string lengths.\n*Always halt execution and provide clear error messages when inputs fail validation.\n\n### Task to Perform\nFollow the examples above to examine each contract and check if it contains this issue. If you find any potential issues, record them using the format below.\n\n### Output Format\n\nIf NO concrete vulnerability found, output a empty array\n\nOtherwise, follow the format below:\n\n```\n[\n    {\n        \"summary\":  \"summary of the vulnerabilities\",\n        \"vulnerability_details\": {\n            \"function_name\": \"Name of the function\",\n            \"description\": \"a brief description of the vulnerability\"\n        },\n    \n        \"code_snippet\": [\n            \"code snippet in the file\"\n        ],\n    \n        \"recommendation\": \"recommendation of how to fix the vulnerability\"\n    \n    }\n]\n```"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [-3000, 1760],
      "id": "5193fc43-9c99-43b7-9bfd-260f63c05d51",
      "name": "SC04:2025 - Lack of Input Validation",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=You are a smart contract auditor. After reading the following vulnerability knowledge and understanding correct and incorrect examples, detect the problem in the contract code.\n\n### Vulnerability Knowledge\n\n**Reentrancy**\nA reentrancy attack exploits the vulnerability in smart contracts when a function makes an external call to another contract before updating its own state. This allows the external contract, possibly malicious, to reenter the original function and repeat certain actions, like withdrawals, using the same state. Through such attacks, an attacker can possibly drain all the funds from a contract.\n\n### Examples\n\n#### Incorrect Example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_Reentrancy {\n    mapping(address => uint) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() external {\n        uint amount = balances[msg.sender];\n        require(amount > 0, \"Insufficient balance\");\n\n        // Vulnerability: Ether is sent before updating the user's balance, allowing reentrancy.\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n\n        // Update balance after sending Ether\n        balances[msg.sender] = 0;\n    }\n}\n```\n\nImpact:\n*The most immediate and impactful consequence is the draining of funds. Attackers exploit vulnerabilities to withdraw more money than they are entitled to, potentially emptying the contract’s balance.\n*An attacker can trigger unauthorized function calls. This can lead to unintended actions being executed within the contract or related systems.\n\n#### Correct Example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_Reentrancy {\n    mapping(address => uint) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() external {\n        uint amount = balances[msg.sender];\n        require(amount > 0, \"Insufficient balance\");\n\n        // Fix: Update the user's balance before sending Ether\n        balances[msg.sender] = 0;\n\n        // Then send Ether\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n```\n\n\n**Suggestion**\n\n*Always ensure that every state change happens before calling external contracts, i.e., update balances or code internally before calling external code.\n*Use function modifiers that prevent reentrancy, like Open Zepplin’s Re-entrancy Guard.\n\n### Task to Perform\nFollow the examples above to examine each contract and check if it contains this issue. If you find any potential issues, record them using the format below.\n\n### Output Format\n\nIf NO concrete vulnerability found, output a empty array\n\nOtherwise, follow the format below:\n\n```\n[\n    {\n        \"summary\":  \"summary of the vulnerabilities\",\n        \"vulnerability_details\": {\n            \"function_name\": \"Name of the function\",\n            \"description\": \"a brief description of the vulnerability\"\n        },\n    \n        \"code_snippet\": [\n            \"code snippet in the file\"\n        ],\n    \n        \"recommendation\": \"recommendation of how to fix the vulnerability\"\n    \n    }\n]\n```"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [-3000, 1960],
      "id": "57b1a8f7-070f-4c32-bfb7-9b451c5a4386",
      "name": "SC05:2025 - Reentrancy",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=You are a smart contract auditor. After reading the following vulnerability knowledge and understanding correct and incorrect examples, detect the problem in the contract code.\n\n### Vulnerability Knowledge\n\n**Flash Loan Attacks**\nFlash loan attacks exploit the ability to borrow large sums of funds without collateral within a single transaction. These attacks leverage the atomic nature of blockchain transactions, where all operations must succeed or fail together. By combining flash loans with other vulnerabilities like oracle manipulation, reentrancy, or faulty logic, attackers can manipulate contract behavior and drain funds.\n\nExamples of Flash Loan Exploits:\n*Oracle Manipulation: Using borrowed funds to skew price oracles, triggering under-collateralized liquidations.\n*Liquidity Pool Draining: Leveraging flash loans to remove liquidity or exploit poorly designed AMM mechanics.\n*Arbitrage Exploits: Exploiting price discrepancies across platforms by manipulating liquidity.\n\nImpact:\n*Loss of Funds: Exploiters can drain protocol reserves or manipulate collateralized loans to steal assets.\n*Market Disruptions: Temporary price manipulation or liquidity depletion affecting users and platforms.\n*Ecosystem Damage: Loss of trust in protocols, resulting in reduced user adoption and financial impact.\n\n**Suggestion**\n\n*Avoid reliance on flash loans in critical logic: Restrict sensitive functions to operate only within validated and predictable conditions.\n*Robust Oracle Design: Use time-weighted average prices (TWAP) or decentralized oracles resistant to manipulation.\n*Comprehensive Testing: Include tests simulating flash loan scenarios and edge cases.\nAccess Control: Limit access to critical functions to prevent unauthorized or malicious transactions.\n\n### Task to Perform\nFollow the examples above to examine each contract and check if it contains this issue. If you find any potential issues, record them using the format below.\n\n### Output Format\n\nIf NO concrete vulnerability found, output a empty array\n\nOtherwise, follow the format below:\n\n```\n[\n    {\n        \"summary\":  \"summary of the vulnerabilities\",\n        \"vulnerability_details\": {\n            \"function_name\": \"Name of the function\",\n            \"description\": \"a brief description of the vulnerability\"\n        },\n    \n        \"code_snippet\": [\n            \"code snippet in the file\"\n        ],\n    \n        \"recommendation\": \"recommendation of how to fix the vulnerability\"\n    \n    }\n]\n```"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [-3000, 2360],
      "id": "4654af26-eb5d-492d-aada-8655463a862e",
      "name": "SC07:2025 - Flash Loan Attacks",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=You are a smart contract auditor. After reading the following vulnerability knowledge and understanding correct and incorrect examples, detect the problem in the contract code.\n\n### Vulnerability Knowledge\n\n**Integer Overflow and Underflow**\nEthereum Virtual Machine (EVM) defines fixed-size data types for integers. This implies that the range of numbers that an integer variable can represent is finite.For instance, a “uint8” (unsigned integer of 8 bits; i.e., non-negative) can only store integers that fall between 0 and 255. The outcome of trying to store any value greater than 255 into an “uint8” will lead to an overflow. Similarly, the outcome of subtracting “1” from “0” will produce 255. This is called underflow.When an arithmetic operation exceeds or falls short of a type’s maximum or minimum size, an overflow or underflow occurs.For signed integers, the outcome will be a bit different. If we try subtracting “1” from an int8 whose value is -128, we get 127. This is because signed int types, which may represent negative values, start over once we reach the highest negative value.Two straightforward examples of this behavior include periodic mathematical functions (adding 2 to the argument of sin leaves the value intact) and odometers in automobiles, which track distance traveled (they reset to 000000 after the maximum number, i.e., 999999, is exceeded).\n\nImportant Note:- In Solidity 0.8.0 and above, the compiler automatically handles checking for overflows and underflows in arithmetic operations, reverting the transaction if an overflow or underflow occurs. Solidity 0.8.0 also introduces the unchecked keyword, which allows developers to perform arithmetic operations without these automatic checks, explicitly permitting overflow without reverting. This can be particularly useful for optimizing gas usage in cases where overflow is not a concern or where the wraparound behavior is desired, similar to how arithmetic behaved in earlier versions of Solidity.\n\n### Examples\n\n#### Incorrect Example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.4.17;\n\ncontract Solidity_OverflowUnderflow {\n    uint8 public balance;\n\n    constructor() public {\n        balance = 255; // Maximum value of uint8\n    }\n\n    // Increments the balance by a given value\n    function increment(uint8 value) public {\n        balance += value; // Vulnerable to overflow\n    }\n\n    // Decrements the balance by a given value\n    function decrement(uint8 value) public {\n        balance -= value; // Vulnerable to underflow\n    }\n}\n```\n\nImpact:\n*An attacker could exploit such vulnerabilities to artificially increase account balances or token amounts, potentially allowing them to withdraw more funds than they legitimately own.\n*An attacker might alter the intended flow of contract logic, leading to unauthorized actions like stealing assets or minting an excessive number of tokens.\n\n#### Correct Example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Solidity_OverflowUnderflow {\n    uint8 public balance;\n\n    constructor() {\n        balance = 255; // Maximum value of uint8\n    }\n\n    // Increments the balance by a given value\n    function increment(uint8 value) public {\n        balance += value; // Solidity 0.8.x automatically checks for overflow\n    }\n\n    // Decrements the balance by a given value\n    function decrement(uint8 value) public {\n        require(balance >= value, \"Underflow detected\");\n        balance -= value;\n    }\n}\n```\n\n\n**Suggestion**\n\n*The simplest approach is to use Solidity compiler version 0.8.0 or higher, as it automatically handles overflow and underflow checks.\n*Make Use of the latest Safe Math Libraries: For the Ethereum community, OpenZeppelin has done a fantastic job creating and auditing secure libraries. Its SafeMath library, in particular, can be used to prevent under/overflow vulnerabilities. It provides functions like add(), sub(), mul(), etc., that carry out basic arithmetic operations and automatically revert if an overflow or underflow occurs.\n\n### Task to Perform\nFollow the examples above to examine each contract and check if it contains this issue. If you find any potential issues, record them using the format below.\n\n### Output Format\n\nIf NO concrete vulnerability found, output a empty array\n\nOtherwise, follow the format below:\n\n```\n[\n    {\n        \"summary\":  \"summary of the vulnerabilities\",\n        \"vulnerability_details\": {\n            \"function_name\": \"Name of the function\",\n            \"description\": \"a brief description of the vulnerability\"\n        },\n    \n        \"code_snippet\": [\n            \"code snippet in the file\"\n        ],\n    \n        \"recommendation\": \"recommendation of how to fix the vulnerability\"\n    \n    }\n]\n```"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [-3000, 2560],
      "id": "36de5ffb-8400-4a5d-8e0a-dfda7509a074",
      "name": "SC08:2025 - Integer Overflow and Underflow",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=You are a smart contract auditor. After reading the following vulnerability knowledge and understanding correct and incorrect examples, detect the problem in the contract code.\n\n### Vulnerability Knowledge\n\n**Insecure Randomness**\nRandom number generators are essential for applications like gambling, game-winner selection, and random seed generation. On Ethereum, generating random numbers is challenging due to its deterministic nature. Since Solidity cannot produce true random numbers, it relies on pseudorandom factors. Additionally, complex calculations in Solidity are costly in terms of gas.\n\nInsecure Mechanisms Create Random Numbers in Solidity: Developers often use block-related methods to generate random numbers, such as:\n\n*block.timestamp: Current block timestamp.\n*blockhash(uint blockNumber): Hash of a given block (only for the last 256 blocks).\n*block.difficulty: Current block difficulty.\n*block.number: Current block number.\n*block.coinbase: Address of the current block’s miner.\n\nThese methods are insecure because miners can manipulate them, affecting the contract’s logic.\n\n### Examples\n\n#### Incorrect Example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract Solidity_InsecureRandomness {\n    constructor() payable {}\n\n    function guess(uint256 _guess) public {\n        uint256 answer = uint256(\n            keccak256(\n                abi.encodePacked(block.timestamp, block.difficulty, msg.sender) // Using insecure mechanisms for random number generation\n            ) \n        );\n\n        if (_guess == answer) {\n            (bool sent,) = msg.sender.call{value: 1 ether}(\"\");\n            require(sent, \"Failed to send Ether\");\n        }\n    }\n}\n```\n\nImpact:\n*Insecure randomness can be exploited by attackers to gain an unfair advantage in games, lotteries, and any other contracts that rely on random number generation. By predicting or manipulating the supposedly random outcomes, attackers can influence the results in their favor. This can lead to unfair wins, financial losses for other participants, and a general lack of trust in the smart contract’s integrity and fairness.\n\n#### Correct Example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\n\ncontract Solidity_InsecureRandomness is VRFConsumerBase {\n    bytes32 internal keyHash;\n    uint256 internal fee;\n    uint256 public randomResult;\n\n    constructor(address _vrfCoordinator, address _linkToken, bytes32 _keyHash, uint256 _fee) \n        VRFConsumerBase(_vrfCoordinator, _linkToken) \n    {\n        keyHash = _keyHash;\n        fee = _fee;\n    }\n\n    function requestRandomNumber() public returns (bytes32 requestId) {\n        require(LINK.balanceOf(address(this)) >= fee, \"Not enough LINK\");\n        return requestRandomness(keyHash, fee);\n    }\n\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n        randomResult = randomness;\n    }\n\n    function guess(uint256 _guess) public {\n        require(randomResult > 0, \"Random number not generated yet\");\n        if (_guess == randomResult) {\n            (bool sent,) = msg.sender.call{value: 1 ether}(\"\");\n            require(sent, \"Failed to send Ether\");\n        }\n    }\n}\n```\n\n\n**Suggestion**\n\n*Using oracles (Oraclize) as external sources of randomness. Care should be taken while trusting the Oracle. Multiple Oracles can also be used.\n*Using Commitment Schemes — A cryptographic primitive that uses a commit-reveal approach can be followed. It also has wide applications in coin flipping, zero-knowledge proofs, and secure computation. E.g.: RANDAO.\n*Chainlink VRF — It is a provably fair and verifiable random number generator (RNG) that enables smart contracts to access random values without compromising security or usability.\n*The Signidice Algorithm — Suitable for PRNG in applications involving two parties using cryptographic signatures.\n*Bitcoin Block Hashes — Oracles like BTCRelay can be used which act as a bridge between Ethereum and Bitcoin. Contracts on Ethereum can request future block hashes from the Bitcoin Blockchain as a source of entropy. It should be noted that this approach is not safe against the miner incentive problem and should be implemented with caution.\n\n### Task to Perform\nFollow the examples above to examine each contract and check if it contains this issue. If you find any potential issues, record them using the format below.\n\n### Output Format\n\nIf NO concrete vulnerability found, output a empty array\n\nOtherwise, follow the format below:\n\n```\n[\n    {\n        \"summary\":  \"summary of the vulnerabilities\",\n        \"vulnerability_details\": {\n            \"function_name\": \"Name of the function\",\n            \"description\": \"a brief description of the vulnerability\"\n        },\n    \n        \"code_snippet\": [\n            \"code snippet in the file\"\n        ],\n    \n        \"recommendation\": \"recommendation of how to fix the vulnerability\"\n    \n    }\n]\n```"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [-3000, 2760],
      "id": "47271cae-cf36-4d02-ae06-acfee5763e2d",
      "name": "SC09:2025 - Insecure Randomness",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=### Output Format\n\nIf NO concrete vulnerability found, output a empty array\n\nOtherwise, follow the format below:\n\n```\n[\n    {\n        \"summary\":  \"summary of the vulnerabilities\",\n        \"vulnerability_details\": {\n            \"function_name\": \"Name of the function\",\n            \"description\": \"a brief description of the vulnerability\"\n        },\n    \n        \"code_snippet\": [\n            \"code snippet in the file\"\n        ],\n    \n        \"recommendation\": \"recommendation of how to fix the vulnerability\"\n    \n    }\n]\n```"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [-3000, 2960],
      "id": "3a0839e2-c6a9-4901-88dc-3bb023ddd3ea",
      "name": "SC10:2025 - Denial Of Service",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=You are a smart contract auditor. After reading the following vulnerability knowledge and understanding correct and incorrect examples, detect the problem in the contract code.\n\n### Vulnerability Knowledge\n\n**Unchecked External Calls**\nUnchecked external calls refer to a security flaw where a contract makes an external call to another contract or address without properly checking the outcome of that call. In Ethereum, when a contract calls another contract, the called contract can fail silently without throwing an exception. If the calling contract doesn’t check the return value, it might incorrectly assume the call was successful, even if it wasn’t. This can lead to inconsistencies in the contract state and vulnerabilities that attackers can exploit.\n\n### Examples\n\n#### Incorrect Example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Solidity_UncheckedExternalCall {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function forward(address callee, bytes _data) public {\n        require(callee.delegatecall(_data));\n    }\n}\n```\n\nImpact:\n*Unchecked external calls can result in failed transactions, causing the intended operations to not be completed successfully. This can lead to the loss of funds, as the contract may proceed under the false assumption that the transfer was successful. *Additionally, it can create an incorrect contract state, making the contract vulnerable to further exploits and inconsistencies in its logic.\n\n#### Correct Example\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0; \n\ncontract Solidity_UncheckedExternalCall {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function forward(address callee, bytes memory _data) public {\n        // Ensure that delegatecall succeeds\n        (bool success, ) = callee.delegatecall(_data);\n        require(success, \"Delegatecall failed\");  // Check the return value to handle failure\n    }\n}\n```\n\n\n**Suggestion**\n\n*Whenever possible, use transfer() instead of send(), as transfer() reverts the transaction if the external call fails.\n*Always check the return value of send() or call() functions to ensure proper handling if they return false.\n\n### Task to Perform\nFollow the examples above to examine each contract and check if it contains this issue. If you find any potential issues, record them using the format below.\n\n### Output Format\n\nIf NO concrete vulnerability found, output a empty array\n\nOtherwise, follow the format below:\n\n```\n[\n    {\n        \"summary\":  \"summary of the vulnerabilities\",\n        \"vulnerability_details\": {\n            \"function_name\": \"Name of the function\",\n            \"description\": \"a brief description of the vulnerability\"\n        },\n    \n        \"code_snippet\": [\n            \"code snippet in the file\"\n        ],\n    \n        \"recommendation\": \"recommendation of how to fix the vulnerability\"\n    \n    }\n]\n```"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [-3000, 2160],
      "id": "09f25abd-9e68-4e62-a7ce-189299c419cd",
      "name": "SC06:2025 - Unchecked External Calls",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "162cf072-03ec-49a2-b87d-820eb155c89e",
              "leftValue": "={{ $json.body.mode }}",
              "rightValue": "trace",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [-3660, 1260],
      "id": "88541cd6-b81b-42cd-b52a-9ca78e37ddef",
      "name": "If"
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [-2404, 2060],
      "id": "5a106850-33c3-4ce4-94b3-93f5e5a6a84e",
      "name": "Respond to Webhook1"
    }
  ],
  "pinData": {},
  "connections": {
    "When chat message received": {
      "main": [
        [
          {
            "node": "SC01:2025 - Improper Access Control",
            "type": "main",
            "index": 0
          },
          {
            "node": "SC02:2025 - Price Oracle Manipulation",
            "type": "main",
            "index": 0
          },
          {
            "node": "SC03:2025 - Logic Errors",
            "type": "main",
            "index": 0
          },
          {
            "node": "SC04:2025 - Lack of Input Validation",
            "type": "main",
            "index": 0
          },
          {
            "node": "SC05:2025 - Reentrancy",
            "type": "main",
            "index": 0
          },
          {
            "node": "SC06:2025 - Unchecked External Calls",
            "type": "main",
            "index": 0
          },
          {
            "node": "SC07:2025 - Flash Loan Attacks",
            "type": "main",
            "index": 0
          },
          {
            "node": "SC08:2025 - Integer Overflow and Underflow",
            "type": "main",
            "index": 0
          },
          {
            "node": "SC09:2025 - Insecure Randomness",
            "type": "main",
            "index": 0
          },
          {
            "node": "SC10:2025 - Denial Of Service",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "SC01:2025 - Improper Access Control",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "SC02:2025 - Price Oracle Manipulation",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "SC03:2025 - Logic Errors",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "SC04:2025 - Lack of Input Validation",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "SC05:2025 - Reentrancy",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "SC06:2025 - Unchecked External Calls",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "SC07:2025 - Flash Loan Attacks",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "SC08:2025 - Integer Overflow and Underflow",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "SC09:2025 - Insecure Randomness",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "SC10:2025 - Denial Of Service",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "SC01:2025 - Improper Access Control",
            "type": "ai_outputParser",
            "index": 0
          },
          {
            "node": "SC02:2025 - Price Oracle Manipulation",
            "type": "ai_outputParser",
            "index": 0
          },
          {
            "node": "SC03:2025 - Logic Errors",
            "type": "ai_outputParser",
            "index": 0
          },
          {
            "node": "SC04:2025 - Lack of Input Validation",
            "type": "ai_outputParser",
            "index": 0
          },
          {
            "node": "SC05:2025 - Reentrancy",
            "type": "ai_outputParser",
            "index": 0
          },
          {
            "node": "SC06:2025 - Unchecked External Calls",
            "type": "ai_outputParser",
            "index": 0
          },
          {
            "node": "SC07:2025 - Flash Loan Attacks",
            "type": "ai_outputParser",
            "index": 0
          },
          {
            "node": "SC08:2025 - Integer Overflow and Underflow",
            "type": "ai_outputParser",
            "index": 0
          },
          {
            "node": "SC09:2025 - Insecure Randomness",
            "type": "ai_outputParser",
            "index": 0
          },
          {
            "node": "SC10:2025 - Denial Of Service",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Respond to Webhook": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "SC01:2025 - Improper Access Control",
            "type": "main",
            "index": 0
          },
          {
            "node": "SC02:2025 - Price Oracle Manipulation",
            "type": "main",
            "index": 0
          },
          {
            "node": "SC03:2025 - Logic Errors",
            "type": "main",
            "index": 0
          },
          {
            "node": "SC04:2025 - Lack of Input Validation",
            "type": "main",
            "index": 0
          },
          {
            "node": "SC05:2025 - Reentrancy",
            "type": "main",
            "index": 0
          },
          {
            "node": "SC06:2025 - Unchecked External Calls",
            "type": "main",
            "index": 0
          },
          {
            "node": "SC07:2025 - Flash Loan Attacks",
            "type": "main",
            "index": 0
          },
          {
            "node": "SC08:2025 - Integer Overflow and Underflow",
            "type": "main",
            "index": 0
          },
          {
            "node": "SC09:2025 - Insecure Randomness",
            "type": "main",
            "index": 0
          },
          {
            "node": "SC10:2025 - Denial Of Service",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SC01:2025 - Improper Access Control": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SC02:2025 - Price Oracle Manipulation": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "SC03:2025 - Logic Errors": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "SC04:2025 - Lack of Input Validation": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "SC05:2025 - Reentrancy": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "SC07:2025 - Flash Loan Attacks": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 6
          }
        ]
      ]
    },
    "SC08:2025 - Integer Overflow and Underflow": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 7
          }
        ]
      ]
    },
    "SC09:2025 - Insecure Randomness": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 8
          }
        ]
      ]
    },
    "SC10:2025 - Denial Of Service": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 9
          }
        ]
      ]
    },
    "SC06:2025 - Unchecked External Calls": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 5
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Respond to Webhook1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "722b5b7b-429f-4f6f-aca1-2dc87cca7375",
  "meta": {
    "instanceId": "022db2fbd0a73e6d486f16c5eb885d1053a420197cf4f3857ab5d1742b50c5ad"
  },
  "id": "jpZgaFkBwMQJMhby",
  "tags": []
}
